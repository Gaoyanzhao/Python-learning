## 列表

#### 创建列表

`ls = []` --- 空列表

`list(序列)` ---  新建一个列表将序列中元素依次添加在列表中

#### 索引和切片

* 索引

  `ls = [12, 34, 56, 78, 90, 35]`

  `len(ls)` ---  获取列表长度

  `[0, len(ls) - 1]`和`[len(ls), -1]` ---  这里操作基本与字符串相同

* 切片

  `ls[start:stop:step]` ---  切取从`start`开始到`stop`为止的`step`为一的字列表

  `ls[:-4:-1]  # [35, 90, 78]` --- 反向获取后三个元素

  `ls[-3:] = ls[:4:-1] ` --- 可以同时给多个位置重新赋值

  `ls[3] = 12` --- 给一个位置重新赋值

  `ls[:3] = 99, 88, 77, 66` ---- 可以给多个位置赋一个值，也可以一个位置赋多个值，赋值的时候数据必须得是一个序列

#### 运算符

* 算数运算符

  `+`  ---  新生成一个列表  把多个列表中的数据合并在新的列表中

  `*`  ---  乘以一个正整数n  新生成一个列表 将原列表中的元素 重复n次 放在新列表中

* 逻辑运算符

  `>=, <=, <, >, ==, !=` ----  列表都可以进行这些操作

* 成员运算符

  `in` 和 `not in` ---  同样适用，和字符串等容器使用规则一样

#### 列表操作

1. **添加元素**

   * `ls.append(19)` ---  在末尾追加

   * `ls.insert(0, 18)` ---- 在指定下标添加元素
   * `ls.extend('abc')` ----  合并其他序列，将其他序列的元素追加在当前列表的末尾

2. **删除元素**

   * `ls.pop(n)` --- 删除指定位置上的元素，默认是删除末尾的元素，会把删除的位置的元素返回
   * `del ls[n]` --- 删除指定位置的元素

   * `ls.remove(56)` --- 删除指定元素，如果元素重复的话也是只能删除第一个元素，如果删除的元素不存在会报错

     ```
     # 把指定的元素都删除掉
     while 71 in nums:
     	nums.remove(71)
     print(nums)
     # for 循环
     for ele in nums:
         if ele == 71:
             nums.remove(71)
     
     nums = [71, 12, 33, 71, 71, 71, 71, 65]
     # 可能会删不干净
     for ele in nums:
         if ele == 71:
             nums.remove(71)
     print(nums)
     # [12, 33, 71, 71, 65]
     ```

     出现这个问题的原因是：
         边遍历元素  同时删除元素同一个列表 导致元素的位置发生变化  数据漏判的情况

     ```
     # 怎么解决这个问题？？？
     
     # 遍历的列表与删除元素的列表不是同一个  但是还得保证元素是相同的
     # 删肯定得是删除的原列表
     # 遍历列表的位置 -- 遍历的一个新的
     for ele in nums[:]:
         if ele == 71:
             nums.remove(71)
     print(nums)
     ```

3. **修改元素**

   利用索引和切边对列表进行修改，**这里的所有操作都是对原来列表本身的操作**

   * `ls.index(12)` ---  获取元素第一次出现的位置，元素不存在就会报错
   * `ls.count(12)`  ---  统计指定元素出现的次数

4. **其他操作**

   * `ls.reverse()` ----  反转列表中的元素，**影响的是列表本身**，`num[::-1]`是生成一个新的

   * `ls.copy()` ---- 对列表进行拷贝

   * `ls.sort(key, reverse=False)`  --- 默认是对列表中的元素按照元素大小进行升序排序

     `reverse `是否在升序排序之后将内容反转  `True `反转 --- 达到了降序的效果

     `key` -- 接受的是一个函数  控制是排序时 元素比较的标准  默认是按照元素大小进行比较的

5. **列表推导式**

   [存放在列表中的元素 元素的来源 元素的筛选]

   ```
   nums = [17, 29, 33, 48, 63]
   # 提取个位数为3并且能被3整除的数据
   new_nums = [i for i in nums if i % 3 == 0 and i % 10 == 3]
   print(new_nums)
   # 提取非空白字符串序列的字符串
   val = ['hello', '\tgood\t', ' ', '\t\n', ' bye\n']
   new_val = [str(ele) for ele in val if not ele.isspace()]
   print(new_val)
   ```

## 二维列表

`[[], [], []]`  ----   在列表中的元素还是列表，二维的

**二维列表的遍历**

```
# 获取每一个小元素 遍历
nums = [[12, 34, 56], [17, 28, 19], [33, 44, 51],[12, 34, 67], [19, 23, 54]]
for ele_list in nums:
    for ele in ele_list:
        print(ele)
```



## 元组

不可变的有序序列，类似于列表

* 列表是可变的，元组是不可变的(元组中元素的地址不允许放生变化)

* 元组是()列表是[]

* 注：()可以表示元组，也可以表示提高表达式的优先级。当元组中只有一个元素的时候，注意一定要加逗号。如果不加逗号的话，解释器就把()解释成了提高表达式优先级的含义了 ，也就不是元组类型的数据

  ```
  t = (10)
  t1 = (10,)
  print(type(t), type(t1)) # <class 'int'> <class 'tuple'>
  ```

* `tuple('abc')  # ('a', 'b', 'c') `  ----  把其他类型的序列转化为元组类型

* 运算符的操作和列表基本类似

  #### **索引和切片**

  `t = (12, 34, 56, 78, 12, 34, 56, 78)`

  `t[:5], t[-5:]` ---  分别表示提取前5个和后5个

  ```
  t[-1] = 77 # TypeError: 'tuple' object does not support item assignment  这里元组中的元素是不允许放生改变的
  
  t = (17, 32, 56, ['a', 'b'])
  t[-1][0] = 'A' # 元组中元素的地址不允许发生变化，但这里操作的是列表内的元素，并不会影响列表本身在元素中的地址
  # 这个不会报错
  print(t) # (17, 32, 56, ['A', 'b'])
  ```

  #### **获取元素**

  `t.index(n)`  ----  获取某个元素第一次出现的位置

  `t.count(n)`  ----  统计某个元素出现的次数



## 字典

无序的可变的容器， 存放的是键值对数据 优点：清晰的表达数据表示的含义

`dict = {key1:value1, key2:value2}`

key -- 理解成就是给数据value的标记 ，标记是不能重复的，而且是不能发生变化的【key的类型必须是不可变的】

字典是无序的【没有索引这一说的】， 定位数据的方式是通过标记key来进行定位的

1. #### **字典的创建**

   - 字面量形式创建

     `person = {'name': '李泽', 'age': 22, 'score': 78, 'sid': 22}`

   - 使用`dict`这个函数进行创建

     `person = dict(name='李德', age=22, score=77, sid=23)`

2. #### **字典的操作**

   `person['gender'] = '男'`   ---   增加新的键值对，如果键存在， 会新值覆盖旧值，  键不存在 就当做新的键值对添加

   `person['score'] = 77`    ----   在字典里边没有`score`这个键的时候表示添加，有的话覆盖之前的值

   `value = person.setdefault('address', '北京')`  ----   没有键就添加，有就什么都不做而且没有返回值

   `person.update({'tel': '1234567890'})`   -----    合并字典

   `person.pop('tel')`  ----   根据键来删除键值对，会把删掉的键值对的值返回

   `del person['gender']`   -----    根据键删除键值对

   `person.popitem()`  -----  随机删除一组键值对

   `person.clear()`  ----  清空字典

   `value = person['name']`  ----   根据键获取值，如果键不存在会报错

   `value = person.get('name', 返回值)`    -----   如果键不存在，默认返回None

   `person.keys()` ---- 获取字典中所有的键

   `person.value()` ---- 获取字典中所有的值

   `person.item()`  ----   获取字典中所有的键值对

   `person.copy()`----  对字典进行拷贝

   `for k in person:`  ---- 直接遍历相当于`person.keys()`

   `in`  ----成员运算符校验的是键是否在字典中

   `for item in person.items():`  ---  既可以获取键又获取值

   `for k, v in person.items():`  ---- 分别获取键和值

   ```
   # 按照年龄降序排序
   
   students = [
       {'name': '剑锋', 'age': 22, 'gender': '男', 'score': 85},
       {'name': '剑锋01', 'age': 21, 'gender': '男', 'score': 88},
       {'name': '剑锋02', 'age': 20, 'gender': '女', 'score': 82},
       {'name': '剑锋03', 'age': 23, 'gender': '男', 'score': 79}
   ]
   students.sort(key=lambda s: s.get('score'), reverse=True)
   ```

   

   



## 集合

类似于字典， 但是在数据中只有键 没有值。
集合存放的是无重复的数据
集合是一个无序可变的的序列
使用场景 --- 用于排重  或者 两个序列中重复项 非重复项等等

1. #### 创建集合

   `s = {12, 34,56}`

   `s = set()` ---  创建一个空集合。**注：这里不可以使用`{}`来创建空集合，`{}`表示的是空字典。**

   `set(序列)`  ----  将其他的序列转化为集合类型，**一般用作对序列中数据的去重**

2. #### 运算符

   `&`  --- 求两个集合的交集放在一个新的集合中

   `|`  ---- 求两个集合的并集

   `^`  --- 求两个集合的非交集

   `-`  ---  求两个集合的差集

   `>= > < <=`判断是否是子集和纯子集

   `== !=`  ---  判断两个集合内容是否一致，不一致

3. #### 集合的操作

   `s.add()` ---- 添加

   `s.pop()`  ----- 删除的是任意一个元素，并把元素返回，集合不能是空

   `s.remove(元素)`  ---  删除，元素必须是成员

   `s.discard(元素)`   ----- 删除

